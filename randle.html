<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Randle - Random Word Game</title>
<link href="https://fonts.googleapis.com/css2?family=Jersey+10:wght@100;300;400;500;700;900&display=swap" rel="stylesheet">
<style>
  body { font-family:'Jersey 10',sans-serif; background:#fff; text-align:center; margin:0; padding:20px; color:#222;}
  h1 { color:#E82B38; }
  #grid { display:grid; grid-template-columns: repeat(5, 50px); grid-gap:5px; justify-content:center; margin:20px auto;}
  .cell { width:50px;height:50px;line-height:50px;border:2px solid #333;font-size:24px;text-transform:uppercase; }
  .correct { background:#E82B38; color:white; }
  .present { background:gold; color:black; }
  .absent { background:#ccc; color:white; }
  #keyboard { margin-top:20px; }
  button.key { margin:2px; padding:10px 12px; font-size:18px; cursor:pointer; }
</style>
</head>
<body>

<h1>Randle</h1>
<p>Guess the 5-letter word related to randomness!</p>

<div id="grid"></div>
<div id="keyboard"></div>
<p id="message"></p>

<script>
const WORD_LENGTH = 5;
const MAX_GUESSES = 6;
let guesses = [];
let currentGuess = "";
let gameOver = false;
let wordQueue = ["random"];

// -- Create grid
const grid = document.getElementById('grid');
for(let i=0;i<WORD_LENGTH*MAX_GUESSES;i++){
  const cell = document.createElement('div');
  cell.className='cell';
  grid.appendChild(cell);
}

// -- Fetch synonyms from Datamuse
async function fetchSynonyms(word){
  try {
    const res = await fetch(`https://api.datamuse.com/words?rel_syn=${word}&max=20`);
    const data = await res.json();
    return data.map(d => d.word.toUpperCase()).filter(w => w.length===WORD_LENGTH);
  } catch { return []; }
}

// -- Generate target word
async function nextWord(){
  if(wordQueue.length===0) wordQueue.push("random");
  const target = wordQueue.shift();
  const newSynonyms = await fetchSynonyms(target);
  wordQueue.push(...newSynonyms);
  return target;
}

// -- Update grid
function updateGrid(){
  for(let r=0;r<MAX_GUESSES;r++){
    for(let c=0;c<WORD_LENGTH;c++){
      const cell = grid.children[r*WORD_LENGTH + c];
      cell.textContent = guesses[r]?.[c] || (r===guesses.length ? currentGuess[c]||"":"");
      if(guesses[r]){
        if(guesses[r][c]===targetWord[c]) cell.className='cell correct';
        else if(targetWord.includes(guesses[r][c])) cell.className='cell present';
        else cell.className='cell absent';
      } else cell.className='cell';
    }
  }
}

// -- Keyboard
const keyboard = document.getElementById('keyboard');
"ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('').forEach(l=>{
  const key = document.createElement('button');
  key.className='key'; key.textContent=l;
  key.onclick=()=> handleInput(l);
  keyboard.appendChild(key);
});
const enterKey=document.createElement('button'); enterKey.className='key'; enterKey.textContent='ENTER'; enterKey.onclick=()=> handleInput('ENTER'); keyboard.appendChild(enterKey);
const backKey=document.createElement('button'); backKey.className='key'; backKey.textContent='‚å´'; backKey.onclick=()=> handleInput('BACK'); keyboard.appendChild(backKey);

let targetWord;

// -- Handle input
function handleInput(letter){
  if(gameOver) return;
  if(letter==='BACK') currentGuess=currentGuess.slice(0,-1);
  else if(letter==='ENTER'){
    if(currentGuess.length!==WORD_LENGTH){ message.textContent='Word too short!'; return; }
    guesses.push(currentGuess);
    updateGrid();
    if(currentGuess===targetWord){ message.textContent='üéâ Correct!'; gameOver=true; setTimeout(startNewWord,2000);}
    else if(guesses.length===MAX_GUESSES){ message.textContent=`‚ùå Word was ${targetWord}`; gameOver=true; setTimeout(startNewWord,2000);}
    currentGuess="";
  } else if(currentGuess.length<WORD_LENGTH) currentGuess+=letter;
  updateGrid();
}

// -- Start a new word
async function startNewWord(){
  guesses=[]; currentGuess=""; gameOver=false; message.textContent="";
  targetWord = await nextWord();
  updateGrid();
}

// -- Initialize
startNewWord();
</script>

</body>
</html>
